# Projeto de Minera√ß√£o de Dados - E-commerce Brasileiro
# An√°lise de dados REAIS da Olist
# Dataset: Brazilian E-Commerce Public Dataset by Olist

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LinearRegression
from sklearn.cluster import KMeans
from sklearn.metrics import accuracy_score, classification_report, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler, LabelEncoder
import warnings
import os

warnings.filterwarnings('ignore')

# Configura√ß√µes de visualiza√ß√£o
plt.style.use('default')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 11


def verificar_arquivos():
    """
    Verifica se os arquivos da Olist est√£o presentes
    """
    arquivos_necessarios = [
        'data/olist_orders_dataset.csv',
        'data/olist_order_items_dataset.csv',
        'data/olist_products_dataset.csv',
        'data/olist_customers_dataset.csv',
        'data/olist_order_reviews_dataset.csv',
        'data/olist_order_payments_dataset.csv'
    ]

    arquivos_encontrados = []
    arquivos_faltando = []

    for arquivo in arquivos_necessarios:
        if os.path.exists(arquivo):
            arquivos_encontrados.append(arquivo)
        else:
            arquivos_faltando.append(arquivo)

    if arquivos_faltando:
        print("‚ùå Arquivos faltando:")
        for arquivo in arquivos_faltando:
            print(f"   - {arquivo}")
        print("\nüì• Para baixar os dados:")
        print("1. Acesse: https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce")
        print("2. Baixe o dataset e extraia os arquivos CSV nesta pasta")
        return False

    print("‚úÖ Todos os arquivos encontrados!")
    return True


def carregar_dados():
    """
    Carrega e processa os dados da Olist
    """
    print("üìÇ Carregando dados da Olist...")

    try:
        # Carregando as tabelas principais
        orders = pd.read_csv('data/olist_orders_dataset.csv')
        order_items = pd.read_csv('data/olist_order_items_dataset.csv')
        products = pd.read_csv('data/olist_products_dataset.csv')
        customers = pd.read_csv('data/olist_customers_dataset.csv')
        reviews = pd.read_csv('data/olist_order_reviews_dataset.csv')
        payments = pd.read_csv('data/olist_order_payments_dataset.csv')

        print(f"‚úÖ Orders: {len(orders):,} registros")
        print(f"‚úÖ Order Items: {len(order_items):,} registros")
        print(f"‚úÖ Products: {len(products):,} registros")
        print(f"‚úÖ Customers: {len(customers):,} registros")
        print(f"‚úÖ Reviews: {len(reviews):,} registros")
        print(f"‚úÖ Payments: {len(payments):,} registros")

        # Fazendo as jun√ß√µes das tabelas
        print("\nüîó Integrando tabelas...")

        # Come√ßando com orders e order_items
        df = orders.merge(order_items, on='order_id', how='inner')
        print(f"   Orders + Items: {len(df):,} registros")

        # Adicionando customers
        df = df.merge(customers[['customer_id', 'customer_state', 'customer_city']],
                      on='customer_id', how='left')
        print(f"   + Customers: {len(df):,} registros")

        # Adicionando products
        df = df.merge(products[['product_id', 'product_category_name', 'product_weight_g']],
                      on='product_id', how='left')
        print(f"   + Products: {len(df):,} registros")

        # Adicionando reviews
        df = df.merge(reviews[['order_id', 'review_score']],
                      on='order_id', how='left')
        print(f"   + Reviews: {len(df):,} registros")

        # Agregando payments por order_id
        payments_agg = payments.groupby('order_id').agg({
            'payment_type': 'first',
            'payment_installments': 'max',
            'payment_value': 'sum'
        }).reset_index()

        df = df.merge(payments_agg, on='order_id', how='left')
        print(f"   + Payments: {len(df):,} registros")

        # Limpeza dos dados
        print("\nüßπ Limpando dados...")

        # Removendo pedidos cancelados e sem review
        df = df[df['order_status'] == 'delivered']
        df = df.dropna(subset=['review_score'])
        print(f"   Ap√≥s limpeza: {len(df):,} registros")

        # Removendo outliers de pre√ßo
        price_q99 = df['price'].quantile(0.99)
        df = df[df['price'] <= price_q99]
        print(f"   Ap√≥s remover outliers: {len(df):,} registros")

        # Limitando sample para performance
        if len(df) > 15000:
            df = df.sample(n=15000, random_state=42)
            print(f"   Sample final: {len(df):,} registros")

        # Criando vari√°veis derivadas
        df['total_value'] = df['price'] + df['freight_value']
        df['order_date'] = pd.to_datetime(df['order_purchase_timestamp'])

        # Tradu√ß√£o das categorias principais para ingl√™s
        category_translation = {
            'beleza_saude': 'health_beauty',
            'esporte_lazer': 'sports_leisure',
            'informatica_acessorios': 'computers_accessories',
            'moveis_decoracao': 'furniture_decor',
            'utilidades_domesticas': 'housewares',
            'relogios_presentes': 'watches_gifts',
            'telefonia': 'telephony',
            'automotivo': 'auto',
            'brinquedos': 'toys',
            'perfumaria': 'perfumery'
        }

        df['product_category_english'] = df['product_category_name'].map(category_translation)
        df['product_category_english'] = df['product_category_english'].fillna('others')

        print(f"‚úÖ Dataset final: {len(df):,} registros x {len(df.columns)} colunas")

        return df

    except FileNotFoundError as e:
        print(f"‚ùå Arquivo n√£o encontrado: {e}")
        return None
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        return None


def analise_exploratoria(df):
    """
    An√°lise explorat√≥ria dos dados
    """
    print("\n=== AN√ÅLISE EXPLORAT√ìRIA ===\n")

    print("üìä Informa√ß√µes b√°sicas:")
    print(f"- Registros: {len(df):,}")
    print(f"- Per√≠odo: {df['order_date'].min().strftime('%Y-%m-%d')} a {df['order_date'].max().strftime('%Y-%m-%d')}")
    print(f"- Estados: {df['customer_state'].nunique()}")
    print(f"- Categorias: {df['product_category_english'].nunique()}")
    print(f"- Clientes √∫nicos: {df['customer_id'].nunique():,}")

    print(f"\nüí∞ Estat√≠sticas financeiras:")
    print(f"- Pre√ßo m√©dio: R$ {df['price'].mean():.2f}")
    print(f"- Frete m√©dio: R$ {df['freight_value'].mean():.2f}")
    print(f"- Valor total m√©dio: R$ {df['total_value'].mean():.2f}")
    print(f"- Parcelas m√©dias: {df['payment_installments'].mean():.1f}")

    print(f"\n‚≠ê Satisfa√ß√£o:")
    print(f"- Nota m√©dia: {df['review_score'].mean():.2f}/5.0")
    satisfeitos = (df['review_score'] >= 4).mean() * 100
    print(f"- Clientes satisfeitos: {satisfeitos:.1f}%")

    print(f"\nüåé Top 10 Estados:")
    print(df['customer_state'].value_counts().head(10))

    print(f"\nüõí Top Categorias:")
    print(df['product_category_english'].value_counts().head(8))

    print(f"\nüí≥ Tipos de Pagamento:")
    print(df['payment_type'].value_counts())

    return df


def criar_visualizacoes(df):
    """
    Cria visualiza√ß√µes dos dados
    """
    print("\n=== GERANDO GR√ÅFICOS ===")

    # Figura 1: An√°lises principais
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))

    # 1. Vendas por estado
    top_states = df['customer_state'].value_counts().head(12)
    top_states.plot(kind='bar', ax=axes[0, 0], color='skyblue')
    axes[0, 0].set_title('Vendas por Estado')
    axes[0, 0].set_xlabel('Estado')
    axes[0, 0].set_ylabel('N√∫mero de Vendas')
    axes[0, 0].tick_params(axis='x', rotation=45)

    # 2. Distribui√ß√£o de pre√ßos
    axes[0, 1].hist(df['price'], bins=50, color='lightgreen', alpha=0.7)
    axes[0, 1].set_title('Distribui√ß√£o de Pre√ßos')
    axes[0, 1].set_xlabel('Pre√ßo (R$)')
    axes[0, 1].set_ylabel('Frequ√™ncia')

    # 3. Avalia√ß√µes
    review_counts = df['review_score'].value_counts().sort_index()
    review_counts.plot(kind='bar', ax=axes[0, 2], color='orange')
    axes[0, 2].set_title('Distribui√ß√£o das Avalia√ß√µes')
    axes[0, 2].set_xlabel('Nota')
    axes[0, 2].set_ylabel('Quantidade')

    # 4. Categorias
    top_categories = df['product_category_english'].value_counts().head(8)
    top_categories.plot(kind='barh', ax=axes[1, 0], color='salmon')
    axes[1, 0].set_title('Top Categorias')
    axes[1, 0].set_xlabel('Vendas')

    # 5. Tipos de pagamento
    payment_counts = df['payment_type'].value_counts()
    axes[1, 1].pie(payment_counts.values, labels=payment_counts.index, autopct='%1.1f%%')
    axes[1, 1].set_title('Tipos de Pagamento')

    # 6. Vendas ao longo do tempo
    monthly_sales = df.groupby(df['order_date'].dt.to_period('M')).size()
    monthly_sales.plot(ax=axes[1, 2], color='purple')
    axes[1, 2].set_title('Vendas Mensais')
    axes[1, 2].set_xlabel('M√™s')
    axes[1, 2].set_ylabel('Vendas')
    axes[1, 2].tick_params(axis='x', rotation=45)

    plt.tight_layout()
    plt.savefig('outputs/analise_exploratoria.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Figura 2: Mapa de correla√ß√£o
    plt.figure(figsize=(10, 8))
    numeric_cols = ['price', 'freight_value', 'payment_installments', 'review_score', 'total_value']
    correlation_matrix = df[numeric_cols].corr()
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
    plt.title('Correla√ß√µes entre Vari√°veis')
    plt.tight_layout()
    plt.savefig('outputs/correlacao_variaveis.png', dpi=300, bbox_inches='tight')
    plt.show()


def classificacao_satisfacao(df):
    """
    Classifica√ß√£o para prever satisfa√ß√£o do cliente
    """
    print("\n=== CLASSIFICA√á√ÉO: SATISFA√á√ÉO DO CLIENTE ===")

    # Target: cliente satisfeito (nota >= 4)
    df['cliente_satisfeito'] = (df['review_score'] >= 4).astype(int)

    print(f"üìä Distribui√ß√£o:")
    satisfeitos = df['cliente_satisfeito'].sum()
    total = len(df)
    print(f"- Satisfeitos: {satisfeitos:,} ({satisfeitos / total * 100:.1f}%)")
    print(f"- Insatisfeitos: {total - satisfeitos:,} ({(total - satisfeitos) / total * 100:.1f}%)")

    # Features para classifica√ß√£o
    features = ['price', 'freight_value', 'payment_installments', 'total_value']
    X = df[features].fillna(0)
    y = df['cliente_satisfeito']

    # Divis√£o treino/teste
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Modelo Random Forest
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Predi√ß√µes e avalia√ß√£o
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)

    print(f"\nüéØ Resultados:")
    print(f"- Acur√°cia: {accuracy:.4f}")
    print(f"\nüìà Relat√≥rio detalhado:")
    print(classification_report(y_test, y_pred, target_names=['Insatisfeito', 'Satisfeito']))

    # Import√¢ncia das features
    feature_importance = pd.DataFrame({
        'feature': features,
        'importance': model.feature_importances_
    }).sort_values('importance', ascending=False)

    plt.figure(figsize=(10, 6))
    plt.barh(feature_importance['feature'], feature_importance['importance'])
    plt.title('Import√¢ncia das Vari√°veis - Satisfa√ß√£o do Cliente')
    plt.xlabel('Import√¢ncia')
    plt.tight_layout()
    plt.savefig('outputs/importancia_features.png', dpi=300, bbox_inches='tight')
    plt.show()

    print(f"üìä Feature mais importante: {feature_importance.iloc[0]['feature']}")

    return model, accuracy


def regressao_precos(df):
    """
    Regress√£o para prever pre√ßos
    """
    print("\n=== REGRESS√ÉO: PREDI√á√ÉO DE PRE√áOS ===")

    # Preparando dados
    df_reg = df.copy()

    # Encoding das vari√°veis categ√≥ricas
    le_category = LabelEncoder()
    le_state = LabelEncoder()
    le_payment = LabelEncoder()

    df_reg['category_encoded'] = le_category.fit_transform(df_reg['product_category_english'].fillna('unknown'))
    df_reg['state_encoded'] = le_state.fit_transform(df_reg['customer_state'].fillna('unknown'))
    df_reg['payment_encoded'] = le_payment.fit_transform(df_reg['payment_type'].fillna('unknown'))

    # Features e target
    features = ['category_encoded', 'state_encoded', 'payment_encoded', 'payment_installments', 'freight_value']
    X = df_reg[features].fillna(0)
    y = df_reg['price']

    # Divis√£o treino/teste
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Modelo de regress√£o
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Predi√ß√µes e avalia√ß√£o
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f"üìä Resultados:")
    print(f"- R¬≤ Score: {r2:.4f}")
    print(f"- MSE: {mse:.2f}")
    print(f"- Pre√ßo m√©dio real: R$ {y_test.mean():.2f}")

    # Gr√°fico predito vs real
    plt.figure(figsize=(10, 6))
    plt.scatter(y_test, y_pred, alpha=0.5)
    plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
    plt.xlabel('Pre√ßo Real (R$)')
    plt.ylabel('Pre√ßo Predito (R$)')
    plt.title('Regress√£o: Pre√ßo Real vs Predito')
    plt.tight_layout()
    plt.savefig('outputs/regressao_precos.png', dpi=300, bbox_inches='tight')
    plt.show()

    return model, r2


def clustering_estados(df):
    """
    Agrupamento de estados por comportamento de compra
    """
    print("\n=== CLUSTERING: SEGMENTA√á√ÉO DE ESTADOS ===")

    # Perfil por estado
    state_profile = df.groupby('customer_state').agg({
        'price': 'mean',
        'freight_value': 'mean',
        'payment_installments': 'mean',
        'review_score': 'mean',
        'order_id': 'count'
    }).round(2)

    state_profile.columns = ['preco_medio', 'frete_medio', 'parcelas_media', 'avaliacao_media', 'total_pedidos']

    # Filtrar estados com pelo menos 50 pedidos
    state_profile = state_profile[state_profile['total_pedidos'] >= 50]

    print(f"üìä Estados analisados: {len(state_profile)}")

    # Normaliza√ß√£o
    scaler = StandardScaler()
    features_scaled = scaler.fit_transform(
        state_profile[['preco_medio', 'frete_medio', 'parcelas_media', 'avaliacao_media']])

    # K-means
    kmeans = KMeans(n_clusters=3, random_state=42)
    clusters = kmeans.fit_predict(features_scaled)
    state_profile['cluster'] = clusters

    print(f"\nüéØ Perfil dos clusters:")
    for cluster in range(3):
        cluster_data = state_profile[state_profile['cluster'] == cluster]
        estados = ', '.join(cluster_data.index.tolist())
        print(f"\nCluster {cluster}: {estados}")
        print(f"  - Pre√ßo m√©dio: R$ {cluster_data['preco_medio'].mean():.2f}")
        print(f"  - Frete m√©dio: R$ {cluster_data['frete_medio'].mean():.2f}")
        print(f"  - Total pedidos: {cluster_data['total_pedidos'].sum():,}")

    # Visualiza√ß√£o
    fig, axes = plt.subplots(1, 2, figsize=(15, 6))

    # Gr√°fico 1: Pre√ßo vs Avalia√ß√£o
    scatter1 = axes[0].scatter(state_profile['preco_medio'], state_profile['avaliacao_media'],
                               c=state_profile['cluster'], cmap='viridis', s=100)
    axes[0].set_xlabel('Pre√ßo M√©dio (R$)')
    axes[0].set_ylabel('Avalia√ß√£o M√©dia')
    axes[0].set_title('Clusters: Pre√ßo vs Avalia√ß√£o')

    # Gr√°fico 2: Volume vs Frete
    scatter2 = axes[1].scatter(state_profile['total_pedidos'], state_profile['frete_medio'],
                               c=state_profile['cluster'], cmap='viridis', s=100)
    axes[1].set_xlabel('Total de Pedidos')
    axes[1].set_ylabel('Frete M√©dio (R$)')
    axes[1].set_title('Clusters: Volume vs Frete')

    plt.tight_layout()
    plt.savefig('outputs/clustering_estados.png', dpi=300, bbox_inches='tight')
    plt.show()

    return kmeans, state_profile


def main():
    """
    Fun√ß√£o principal
    """
    print("üõí PROJETO DE MINERA√á√ÉO DE DADOS - E-COMMERCE BRASILEIRO")
    print("üìä Dataset: Brazilian E-Commerce Public Dataset by Olist")
    print("üîó Fonte: https://www.kaggle.com/datasets/olistbr/brazilian-ecommerce\n")

    # 1. Verificar arquivos
    if not verificar_arquivos():
        return

    # 2. Carregar dados
    print("\n1. Carregando dados...")
    df = carregar_dados()
    if df is None:
        return

    # 3. An√°lise explorat√≥ria
    print("\n2. An√°lise explorat√≥ria...")
    df = analise_exploratoria(df)

    # 4. Visualiza√ß√µes
    print("\n3. Criando visualiza√ß√µes...")
    criar_visualizacoes(df)

    # 5. Classifica√ß√£o
    print("\n4. Aplicando classifica√ß√£o...")
    rf_model, accuracy = classificacao_satisfacao(df)

    # 6. Regress√£o
    print("\n5. Aplicando regress√£o...")
    lr_model, r2 = regressao_precos(df)

    # 7. Clustering
    print("\n6. Aplicando clustering...")
    kmeans, state_profile = clustering_estados(df)

    # Resumo final
    print("\n" + "=" * 60)
    print("üéØ RESUMO DOS RESULTADOS")
    print("=" * 60)
    print(f"üìä Dataset: {len(df):,} registros reais")
    print(f"üìÖ Per√≠odo: {df['order_date'].min().strftime('%Y-%m-%d')} a {df['order_date'].max().strftime('%Y-%m-%d')}")
    print(f"üåé Estados: {df['customer_state'].nunique()}")
    print(f"üéØ Acur√°cia Classifica√ß√£o: {accuracy:.4f}")
    print(f"üìà R¬≤ Regress√£o: {r2:.4f}")
    print(f"üîç Clusters: {len(state_profile)} estados em 3 grupos")
    print("=" * 60)
    print("‚úÖ An√°lise conclu√≠da! Gr√°ficos salvos em PNG.")

    return df, rf_model, lr_model, kmeans


if __name__ == "__main__":
    df, rf_model, lr_model, kmeans = main()